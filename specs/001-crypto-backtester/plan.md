# Implementation Plan: Crypto Strategy Backtester

**Branch**: `001-crypto-backtester` | **Date**: 2026-02-21 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-crypto-backtester/spec.md`

## Summary

Build a crypto trading strategy backtester that parses plain-English trading ideas into validated JSON rule sets via a single AI API call, then runs deterministic client-side backtests on bundled historical OHLCV data for 8 cryptocurrencies. The app displays professional analytics: candlestick charts with trade markers, equity curves vs buy-and-hold benchmark, 14 performance metrics, trade logs, and an audit panel. Two strategy modes (standard signal-based and DCA), comparison mode, asset swap, demo presets, and run history round out the feature set.

Technical approach: Next.js 14+ App Router with TypeScript strict mode, Zod-validated schemas with discriminated unions, pure-function engine modules (indicators → evaluator → backtest → metrics), TradingView lightweight-charts for candlesticks, Recharts for equity/analytics charts, shadcn/ui + Tailwind for dark-mode-first UI, Vitest for math-focused unit tests.

## Technical Context

**Language/Version**: TypeScript 5.x (strict mode, no `any`, no `@ts-ignore`)
**Primary Dependencies**: Next.js 14+ (App Router), Zod, @anthropic-ai/sdk, Recharts, lightweight-charts v5, shadcn/ui, Tailwind CSS
**Storage**: None (in-memory per browser session; OHLCV data is bundled static JSON ~200KB)
**Testing**: Vitest (unit tests for pure-function modules only; no snapshot/E2E tests)
**Target Platform**: Web (modern browsers), deployed to Vercel
**Project Type**: Web application (single-page with one API route)
**Performance Goals**: Backtest computation completes without user-perceptible delay; AI parse < 5 seconds
**Constraints**: Client-side computation only; single network call (AI parser); offline-capable via Demo Mode
**Scale/Scope**: 8 assets, daily timeframe, single user per session, no persistence

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-checked after Phase 1 design.*

| # | Principle | Status | Notes |
|---|-----------|--------|-------|
| I | AI-Math Boundary | PASS | Single API route (`/api/parse`) for NL→JSON. Engine, indicators, metrics are pure client-side math with zero AI dependency. Demo Mode works without AI. Boundary is explicit in module structure. |
| II | TypeScript Strict & Zod | PASS | All schemas defined with Zod (discriminated unions for Mode, Operand, Sizing). TypeScript strict mode enforced. Zod validates all external boundaries (AI output, URL params, config). JSDoc on all exports. |
| III | Pure Functions & Layered Dependencies | PASS | Module flow: `types → indicators → engine → metrics → UI`. All computation modules are pure functions. No circular dependencies. No mutations or global state. |
| IV | Math-First Testing | PASS | Vitest tests for all indicators (hand-calculated values), engine (determinism proof), metrics (formula verification), Zod validators, and invariant checks. No snapshot or E2E tests. Implementation-first testing. |
| V | Demo Resilience | PASS | 6 presets + 4 known-good snapshots work without AI. Error fallback suggests presets. No blank screens, no unhandled rejections. Loading/error/empty states all handled. |
| VI | Professional UX & Charting | PASS | lightweight-charts v5 for candlesticks with markers + overlays. Recharts for equity curves + drawdown. Dark mode default with Tailwind slate palette. All UI states (loading, error, empty, populated) covered. |
| VII | Scope Discipline | PASS | Every feature maps to either the demo script or a judging criterion. No premature abstraction. Uses Next.js, shadcn, Tailwind directly. Functionality > polish. |
| VIII | Phased Implementation | PASS | 3 phases with explicit done-criteria. Phase 1: engine (all tests pass, programmatic backtest works). Phase 2: UI v1 (end-to-end in browser by Day 3). Phase 3: polish + features. No new features after Phase 3. |

## Project Structure

### Documentation (this feature)

```text
specs/001-crypto-backtester/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Technology research findings
├── data-model.md        # Complete data model (Zod schemas)
├── quickstart.md        # Setup and development guide
├── contracts/
│   └── parse-api.md     # POST /api/parse contract
├── checklists/
│   └── requirements.md  # Specification quality checklist
└── tasks.md             # Task list (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── app/
│   ├── layout.tsx                 # Root layout (dark mode, fonts)
│   ├── page.tsx                   # Main page (phase-based rendering)
│   ├── globals.css                # Tailwind base + custom styles
│   └── api/
│       └── parse/
│           └── route.ts           # POST: prompt → Claude → Zod-validated RuleSet
├── components/
│   ├── StrategyInput.tsx          # Textarea, asset dropdown, config fields, Parse button
│   ├── RuleConfirmation.tsx       # Rule cards + warnings + JSON toggle + Confirm button
│   ├── PriceChart.tsx             # lightweight-charts candlestick + markers + overlays
│   ├── EquityCurve.tsx            # Recharts: strategy vs benchmark + drawdown
│   ├── MetricsGrid.tsx            # 4x3 color-coded metric cards
│   ├── AuditPanel.tsx             # Collapsible execution assumptions
│   ├── TradeLog.tsx               # Sortable trade table
│   ├── ComparisonView.tsx         # Overlaid equity + side-by-side metrics + deltas
│   ├── PresetGallery.tsx          # Preset cards + known-good snapshot buttons
│   ├── RunHistory.tsx             # Session history sidebar
│   ├── LandingHero.tsx            # Tagline + how-it-works + preset grid
│   └── ui/                        # shadcn/ui primitives (auto-generated)
├── engine/
│   ├── backtest.ts                # Main loop: runBacktest() → standard/DCA branches
│   ├── evaluator.ts               # evaluateCondition() + evaluateGroup()
│   ├── benchmark.ts               # computeBenchmark() (buy & hold, same fees)
│   └── types.ts                   # Engine-internal types (OpenPosition, IndicatorCache)
├── indicators/
│   ├── sma.ts
│   ├── ema.ts
│   ├── rsi.ts
│   ├── macd.ts
│   ├── bollinger.ts
│   ├── atr.ts
│   ├── pctChange.ts
│   └── index.ts                   # Barrel export + indicator registry
├── metrics/
│   └── compute.ts                 # computeMetrics(): all 14 formulas
├── types/
│   ├── strategy.ts                # Zod schemas + inferred types + validateRuleSetInvariants()
│   └── results.ts                 # BacktestResult, Trade, EquityPoint, AuditInfo, etc.
├── data/
│   ├── loader.ts                  # fetch + cache OHLCV JSON from /public/data/
│   ├── presets.ts                 # 6 preset RuleSet objects
│   └── snapshots.ts               # 4 known-good run snapshot configs
└── lib/
    ├── parser.ts                  # Claude API call wrapper + retry + validation pipeline
    └── utils.ts                   # Shared formatting utilities

public/
└── data/
    ├── BTC_1D.json                # ~25KB each
    ├── ETH_1D.json
    ├── SOL_1D.json
    ├── BNB_1D.json
    ├── XRP_1D.json
    ├── DOGE_1D.json
    ├── ADA_1D.json
    └── AVAX_1D.json

__tests__/
├── indicators/
│   ├── sma.test.ts
│   ├── ema.test.ts
│   ├── rsi.test.ts
│   ├── macd.test.ts
│   ├── bollinger.test.ts
│   ├── atr.test.ts
│   ├── pctChange.test.ts
│   └── crossDetection.test.ts
├── engine/
│   ├── backtest.test.ts           # Standard mode + determinism proof
│   ├── evaluator.test.ts
│   ├── noLookahead.test.ts        # Anti-lookahead rule verification
│   ├── dcaMode.test.ts            # DCA: interval buying, capital depletion, partial buy
│   └── invariants.test.ts         # validateRuleSetInvariants() tests
└── metrics/
    └── compute.test.ts            # All 14 formulas with hand-calculated values

scripts/
├── fetch-data.ts                  # Download OHLCV from Binance public API
└── test-engine.ts                 # CLI script: run hardcoded strategy → print results
```

**Structure Decision**: Single Next.js project with clear module boundaries. No monorepo, no separate packages. The `engine/`, `indicators/`, `metrics/`, and `types/` directories form the pure-function computation layer. Components consume them. The single API route (`/api/parse`) is the only server-side code.

## Phased Implementation

### Phase 1 — ENGINE (Days 1-2)

**Goal**: All pure-function modules implemented and tested. A backtest can be run programmatically with a preset RuleSet and produces correct metrics.

**Modules (in dependency order)**:

1. **Types & Schemas** (`src/types/strategy.ts`, `src/types/results.ts`)
   - All Zod schemas with discriminated unions
   - `validateRuleSetInvariants()` function
   - Inferred TypeScript types exported
   - Tests: `__tests__/engine/invariants.test.ts`

2. **Indicators** (`src/indicators/`)
   - SMA, EMA, RSI (Day 1)
   - MACD, Bollinger Bands, ATR, pctChange (Day 2)
   - All return `(number | null)[]` aligned with input length
   - Null for warmup candles
   - Tests: hand-calculated expected values for each

3. **Condition Evaluator** (`src/engine/evaluator.ts`)
   - `evaluateCondition()`: resolve operands + apply operator
   - `evaluateGroup()`: AND/OR over conditions
   - Cross detection: `crosses_above`, `crosses_below` (requires `i >= 1`)
   - Position-scope: `pnl_pct`, `bars_in_trade`
   - Tests: `__tests__/engine/evaluator.test.ts`

4. **Backtest Engine** (`src/engine/backtest.ts`)
   - `runBacktest()` dispatcher (standard vs DCA)
   - `runStandardBacktest()`: warmup → signal loop → mark-to-market → force-close
   - `runDCABacktest()`: interval buying → cash constraint → partial buy → equity tracking
   - Anti-lookahead: signal on close[i], execute at open[i+1]
   - Fee/slippage: adverse direction, applied on entry and exit
   - Tests: `__tests__/engine/backtest.test.ts`, `noLookahead.test.ts`, `dcaMode.test.ts`

5. **Benchmark** (`src/engine/benchmark.ts`)
   - `computeBenchmark()`: buy at first tradable open, hold, same fees
   - Equity curve at every candle
   - Tests: included in backtest.test.ts

6. **Metrics Calculator** (`src/metrics/compute.ts`)
   - All 14 formulas from spec §10
   - Daily return series computation
   - Sharpe (√365, population stdev, rf=0), Sortino, Max DD, Profit Factor, etc.
   - Edge cases: 0 trades, 1 trade, no wins, no losses
   - `AuditInfo` builder
   - Tests: `__tests__/metrics/compute.test.ts`

7. **AI Parser API Route** (`src/app/api/parse/route.ts`)
   - System prompt with schema definition + 5 few-shot examples
   - Claude API call via `@anthropic-ai/sdk`
   - Validation pipeline: strip fences → JSON.parse → Zod → invariants → confidence
   - Retry once on failure
   - Error response with suggestions

8. **Demo Mode Presets** (`src/data/presets.ts`, `src/data/snapshots.ts`)
   - 6 preset RuleSet JSON objects
   - 4 known-good snapshot configs (preset + asset + date range)

9. **CLI Test Script** (`scripts/test-engine.ts`)
   - Run hardcoded RSI strategy on BTC data → print trades + metrics
   - Validates end-to-end programmatic flow

**Done criteria**: `pnpm test` passes all unit tests. `scripts/test-engine.ts` prints correct trade log and metrics for a preset strategy.

---

### Phase 2 — UI v1 (Day 3) — CRITICAL CHECKPOINT

**Goal**: Full loop works end-to-end in the browser. Type prompt → see rules → confirm → see charts and metrics. Presets work.

**Modules**:

1. **Data Loader** (`src/data/loader.ts`)
   - Fetch OHLCV JSON from `/public/data/` on demand
   - Cache in memory (React context or module-level)

2. **App State & Layout** (`src/app/page.tsx`, `src/app/layout.tsx`)
   - Phase-based rendering (input → parsing → confirming → running → results)
   - React Context for AppState
   - Dark mode default (`className="dark"` on html)
   - Two-panel layout (left sidebar ~350px + main area flex-1)

3. **Strategy Input** (`src/components/StrategyInput.tsx`)
   - Textarea for strategy description
   - Asset dropdown (8 assets)
   - Date range, initial capital, fee/slippage inputs
   - Parse button → calls `/api/parse`

4. **Rule Confirmation** (`src/components/RuleConfirmation.tsx`)
   - Display parsed rules as readable cards
   - Show warnings and parser confidence
   - JSON editor toggle (Tabs component)
   - Confirm button → triggers backtest

5. **Price Chart** (`src/components/PriceChart.tsx`)
   - lightweight-charts candlestick series
   - Trade markers (green ▲ buy, red ▼ sell)
   - Dark mode styling

6. **Results Dashboard**
   - `MetricsGrid.tsx`: 4x3 cards with color coding (green positive, red negative)
   - `TradeLog.tsx`: sortable table with all trade details
   - Basic layout — functional, not polished

7. **Preset Gallery** (`src/components/PresetGallery.tsx`)
   - Preset strategy cards → load directly (skip AI)
   - Known-good snapshot buttons → one-click demo

**Done criteria**: Full flow works in browser. Presets work without AI. Charts render. Metrics display. This is the DAY 3 CHECKPOINT — if not complete, stop all other work and fix it.

---

### Phase 3 — POLISH + FEATURES (Days 4-5)

**Goal**: Demo script from spec can be executed without failure. Feature freeze at end of Day 5.

**Day 4 modules**:

1. **Equity Curve Chart** (`src/components/EquityCurve.tsx`)
   - Recharts ComposedChart: strategy vs benchmark areas
   - Gradient fills, dashed benchmark line
   - Drawdown sub-chart with `baseValue={0}`
   - `syncId` for linked hover
   - Dark mode styling

2. **Indicator Overlays** on price chart
   - SMA/EMA lines, Bollinger bands on candlestick chart
   - Conditionally rendered based on strategy indicators used

3. **Dark Mode Polish**
   - Full color pass across all components
   - Consistent slate palette
   - Professional typography

4. **Metrics Grid Polish**
   - Color-coded cards with proper number formatting
   - Currency, percentage, ratio formatting

5. **Audit Panel** (`src/components/AuditPanel.tsx`)
   - Collapsible panel showing all execution assumptions
   - All AuditInfo fields displayed

6. **Loading States & Landing Hero**
   - `LandingHero.tsx`: tagline + 3-step how-it-works + preset grid
   - Skeleton loaders during parse
   - Brief animation during backtest (~100ms real)

**Day 5 modules**:

7. **Comparison Mode** (`src/components/ComparisonView.tsx`)
   - "Compare with..." button → second strategy input
   - Overlaid equity curves (two series on same chart)
   - Side-by-side metrics with delta arrows (green up / red down)
   - Both strategies re-run on asset swap

8. **Swap Asset** — Re-run both strategies instantly on new asset

9. **Run History** (`src/components/RunHistory.tsx`)
   - Sidebar list of previous runs
   - Each entry: strategy name, asset, key metrics preview
   - Click to restore full results

10. **Edge Cases & Error UX**
    - 0 trades: clear message
    - 1 trade: force-close, metrics edge cases
    - Warmup > range: warning
    - DCA capital depletion: skip/partial buy
    - Parse fail: friendly error + preset fallback
    - Low confidence: prominent warnings

11. **Snapshot Verification**
    - Run all 4 known-good snapshots
    - Verify non-zero trades, interesting charts, reasonable metrics

**Done criteria**: The 2:30 demo script can be executed without failure. All edge cases handled. Feature freeze.

---

### Post-Phase 3 (Days 6-7)

No new features. Only:
- Mobile responsiveness
- Export/share (JSON/CSV download, URL-encoded snapshot)
- Vercel deployment + live URL verification
- README with architecture, setup, screenshots
- Code cleanup (dead code removal, JSDoc, naming consistency)
- Stress testing (15+ prompts, verify results)
- Demo video recording (3-4 takes, edit to 2:30)

## Complexity Tracking

No constitution violations. All principles satisfied as documented in the Constitution Check above.
